---
sidebar_position: 3
sidebar_label: "2. WSGI server"
---

The repository for this section is located at branch **[2.2_three_way_merge](https://github.com/highlander-spirou/microgo/tree/1_Monolith_architecture)**

# The Problem

To be honest, our website sucks. With a constant five seconds throttle, each request tooks 5s to complete!!! On top of that, the second user have to stuck for 5s to wait for the server to process the `upload` route of the first user (eventhough the second user may not be using the `upload` route after all ü§∑‚Äç‚ôÇÔ∏è)

We will fix this problem by cale the Flask instances. After all, the sole purpose of `microservices` architect is to scale. However, we will use the traditional method: `nginx` and `wsgi`. Instead of having one Flask application to process one request, we will use `gunicorn's wsgi` to spin up multiple Flask instances (under the same local IPs) and using `nginx` to route multiple `gunicorn` containers to the user. 

<div style={{textAlign: "center"}}>
    <img src="/img/wsgi_nginx.png" style={{width: "400px", height: "250px"}}></img>
</div>
<!-- ![nginx wsgi diagram](/img/wsgi_nginx.png) -->

By this way, eventhough we still have to stuck for 5s if a user access `upload` route, we will have other Flask instance to spare üòé 

For detail explaination about `nginx` & `gunicorn wsgi` visit: **[WSGI & Nginx explain](/docs/tutorial-basics/wsgi-and-nginx)**.

**Let's learn about the changes in the following page üëá**

**[1. Network change](/docs/wsgi_server/bridge-network)** - Change from *host* network to *bridge* network 

**[2. Gunicorn](/docs/wsgi_server/gunicorn)** - Implement of `gunicorn`




## Gunicorn WSGI interface:

### Create gunicorn_config.py

The core application does not change (since we want an incremental upgrade to the application, not to introduce breaking changes).

We renamed the `index.py` to `server.py`, and create `gunicorn_config.py` to run `gunicorn` interface.

```mdx title="Monolith"
‚îÇ   # Seperate the controller when the logic gets complicates (and reduce the import of `index.py`)
‚îú‚îÄ‚îÄ controllers
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ middleware
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ modules
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ logs
‚îÇ
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ instantiation.py
‚îú‚îÄ‚îÄ server.py
‚îî‚îÄ‚îÄ gunicorn_config.py
```

### Update the `ENTRYPOINT`

We also update the `ENTRYPOINT` of the image to call the gunicorn service

```Dockerfile title="Dockerfile"
FROM python:3.10.12-slim
RUN pip install poetry==1.7.1

WORKDIR /app

COPY pyproject.toml poetry.lock README.md ./
COPY monolith ./monolith

RUN poetry config virtualenvs.create false
RUN poetry install --no-root

WORKDIR /app/monolith

// highlight-start
ENTRYPOINT ["poetry", "run", "gunicorn", "-c", "gunicorn_config.py", "server:app"]
// highlight-end
```

### Mount the `logs` folder

We want to be able to investigate the log, so we mount the `logs` folder into the docker volume. Since the `logging` module default mode is append mode, new log from all the containers will be written into a single `app_logs.log` file, create a central debug point for our distributed service

```yml title="docker-compose.yml"
services:
  flask:
    volumes:
      - ./monolith/logs:/app/monolith/logs
```

## Nginx

Nginx will expose the port 80. But in this example, we have setup Postman to test on port 5000. So we will map the nginx container port 80 to the host port 5000.

We also need to make sure that the Nginx depends on `Flask` service, since we need the gunicorn open the corresponding port -> register to route table -> proxy_pass by `nginx`

```conf title="nginx.conf"
events {
    worker_connections 1000;
}

http {
    server {
        listen 80;

        location / {
            proxy_pass http://flask:5000;
        }
    }
}
```

```yml title="docker-compose.yml"
nginx:
image: nginx:latest
depends_on:
    - flask
networks:
    - microgo
ports:
    - "5000:80"
```

